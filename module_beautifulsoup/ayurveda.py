'''Парсинг страницы с препаратами аюрведа

В функциональном стиле, вызывая только функции, прочие блоки являются только декоративным уведомлением о процессе работы
'''

import requests
from bs4 import BeautifulSoup
import csv

HOST = 'https://stopgame.ru' # Константа адреса хоста для парса
URL = 'https://stopgame.ru/articles' # Константа адреса конкретной страницы для парса

# Чтобы сайт не активировал защиту от ботов, потребуется пробрасывать заголовки
# В просмотре кода страницы для парса, выбирается вкладка "Network" и на ней копируются заголовки accept и user agent
# На сайте примере отсутствуют данные поля
HEADERS = {
    'accept': '',
    'user-agent': ''
}

def get_html(url, params=''):
    '''Взятие html
    url - страница парса
    params - дополнительный код в адресе страницы, до следующей страницы для парса
    '''
    res = requests.get(url, headers=HEADERS, params=params) # Запрос на страницу для взятия hrml
    return res

# Необязательное уведомление
html = get_html(URL)
try:
    html.raise_for_status()
except Exception as e:
    print('Ошибка при загрузке страницы: ' + str(e))
else:
    print(f'Статут: {html.status_code}. Запрос выполнен успешно')


def get_content(html):
    '''Функция принимающая html, для последующего получения (парсинга) контента модулем BeautifulSoup'''
    soup = BeautifulSoup(html, 'html.parser')  # Получение объекта страницы

    # В просмотре кода страницы, для парса определяется общий класс целевых элементов
    # Он и его контейнер станут применяться для получения доступа к каждому входящему в него целевому элементу
    items = soup.find_all('div', class_='_default-grid_4loqg_213')  # Получение множества элементов - find_all, для взятия одного элемента - find
    cards = []  # Массив для сохранения отдельных элементов целевого объекта

    # Цикл, итерирующий весь целевой блок, в который входят отдельные элементы целевого объекта
    # Аналогично, поиск ведется от контейнера до целевого элемента для взятия
    # Каждый найденный элемент добавляется в соответствующую категорию массива для сохранения данных
    # Если искомый элемент находится во вложенном контейнере, то могут применяться последовательные методы, например: find().find()
    for item in items:
        cards.append(
            {
                'Title': item.find('section', class_='_card__content_givrd_398').get_text(),
                'Description': item.find('span', class_='_card__subtitle_givrd_1').get_text()
            }
        )
    return cards









