'''Применение полиморфизма
Благодаря наличию динамической типизации, интерпретатор в момент выполнения кода, всегда автоматически определяет тип
объекта, что в отличие от статических языков программирования, позволяет применять объекты других классов.
Для объектов, важным останется только наличие соответствующего для работы поведения.

В Python, как в языке с динамической типизацией, полиморфизм присутствует повсюду, переменные, параметры и многие
функции способны принимать абсолютно любой тип данных, который они могут обработать.
Что позволяет совершать операции, основываясь только на определении у объектов необходимых одноименных методов

Так, например, в цикле демонстрируется получение общего интерфейса взаимодействия через полиморфную переменную
одноименного метода, в каждом из объектов, тогда как каждый отдельный метод имеет несвязанную с прочими реализацию.
Это позволяет сократить код и исключить необходимость в обработке каждого типа данных по отдельности.
'''


class Rectangle:
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def get_area(self):
        return self.a * self.b
    def __str__(self):
        return f'Rectangle {self.a}x{self.b}'


class Square:
    def __init__(self, a):
        self.a = a
    def get_area(self):
        return self.a ** 2
    def __str__(self):
        return f'Square {self.a}x{self.a}'


class Circle:
    def __init__(self, r):
        self.r = r
    def get_area(self):
        return 3.14 * self.r ** 2
    def __str__(self):
        return f'Circle radius={self.r}'


if __name__ == '__main__':
    rec1 = Rectangle(3, 4)
    rec2 = Rectangle(12, 5)

    sq1 = Square(5)
    sq2 = Square(7)

    cir1 = Circle(3)
    cir2 = Circle(4)

    figure = [rec1, rec2, sq1, sq2, cir1, cir2]
    for i in figure:
        print(f'{i}:', i.get_area())










