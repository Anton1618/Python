'''Доступ к атрибутам ч1. Применение атрибута __setattr__

Рассматривается:
- Установка правил для значений свойств в конструкторе
    Метод позволяет задать правила, при создании объекта, но уязвим,
    потому как в дальнейшем свойства могут быть изменены после инициализации объекта

- Установка правил для значений свойств в методе __setattr__
    Метод позволяет задать правила при установке или прямом обращении к атрибуту, но уязвим,
    потому как в дальнейшем атрибуту может быть назначено новое значение через словарь свойств

- Установка правил для возможности определения только разрешенных атрибутов в методе __setattr__
    Коллекция разрешенных атрибутов указывается в неизменяемой коллекции, а правила в методе учитывают её состав.
    Позволяет исключить установку или прямое обращение к атрибуту, но уязвим,
    потому как может быть создан новый атрибут с любым значением через словарь свойств

-- Установка правил в специальных геттерах и сеттерах декоратора property
    (смотреть часть 2)
'''


# Требуется задание определенной логики для установки значений
# - Обязательное наличие имени объекта - атрибут name
# - Значение возраста объекта должно находиться в диапазоне от 1 до 15 не включительно
# - Исключение возможности создания новых атрибутов


class Cat:
    # Список разрешенных атрибутов в неизменяемой коллекции класса, для исключения возможности создания новых
    FIELDS = ('name', 'age')

    '''def __init__(self, name, age):
        Для соблюдения правил, устанавливаются исключения в конструкторе
        Но исключения станут возбуждаться только при создании объекта. 
        Что позволяет в дальнейшем позволяет изменить заданные свойства, поэтому данный метод не применяется   
        if not name:
            raise AttributeError('Name cannot be empty')
        if age not in range(1, 15):
            raise AttributeError('Age should be in 1-15')
        self.name = name
        self.age = age'''

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        return f'Сat named {self.name}, he is {self.age} years old'

    def __setattr__(self, key, value):
        '''Для соблюдения правил, устанавливаются исключения в методе __setattr__
        Метод станет автоматически вызываться при любой установке значения по имени атрибута
        # Задание правила для установки только разрешенных атрибутов
         Проверка осуществляется по установленным идентификаторам в коллекции-константе'''
        if key not in self.FIELDS:
            raise AttributeError(f'Only allowed {self.FIELDS}')
        if key == 'name' and not value:
            raise AttributeError('Name cannot be empty')
        if key == 'age' and value not in range(1, 15):
            raise AttributeError('Age should be in 1-15')
        self.__dict__[key] = value


if __name__ == '__main__':
    print('Благодаря наличию метода __setattr__, соблюдается:\n'
          '- Корректность значений, при создании объекта,\n'
          '- Корректность значений, при изменении значения по прямому обращению к атрибуту объекта,\n'
          'Благодаря наличию статического атрибута класса - неизменяемой коллекции со списком разрешенных атрибутов\n'
          '- Исключается возможность создания нового атрибута, по прямому обращению к объекту')
    # tom = Cat('Tom', 1000) # AttributeError: Age should be in 1-15
    tom = Cat('Tom', 1)
    # tom.age = 1000 # AttributeError: Age should be in 1-15
    tom.age = 5
    # tom.age2 = 1000 # AttributeError: Only allowed ('name', 'age')
    print(tom)
    print()

    print('Но благодаря наличию словаря свойств, имеется уязвимость для возможности:\n'
          '- Присвоения нового некорректного значения\n'
          '- Присвоения нового атрибута с некорректным значением')
    tom.__dict__['age'] = 1000
    print(tom)
    tom.__dict__['abracadabra'] = 'пользовательское свойство'
    print(tom.__dict__)
    print()
