'''Методы __getitem__, __setitem__ и __delitem__ для построения пользовательских контейнеров

Установка каждого из методов, вносит определенный функционал для работы с элементами объекта как содержимым коллекции:
- метод __getitem__ - позволяет осуществлять получение элемента по индексу;
- метод __setitem__ - позволяет осуществлять установку нового элемента по индексу;
- метод __delitem__ - позволяет осуществлять удаление элемента по индексу.
Методы применяются в протоколах построения пользовательских контейнеров, например, для большего сходства с типами
встроенных коллекций.


Создание классов:
- Построение базового класса ImmutableContainer, для создания на его основе неизменяемого контейнера.
Определяются методы __getitem__ и __len__.
Получение элемента в объекте, станет осуществляться через индексирование:
    в коде - self.data[key], в инструкциях для объекта - data[key];

- Построение производного класса MutableContainer, на основе предыдущего,
для создания на его основе изменяемого контейнера. Определяются методы __setitem__ и __delitem__.
Присвоение элемента объекту, станет осуществляться через индексирование:
    в коде - self.data[key] = value, в инструкциях для объекта - data[key] = value
Удаление элемента объекта, также станет осуществляться через индексирование:
    в коде - del self.data[key], в инструкциях для объекта - del data[key];

- Построение производного класса IterableContainer, на основе предыдущего,
для создания на его основе итерируемого контейнера. Определяются методы __iter__ и __next__.
Демонстрируется возможность как применения автоматического задействия ранее определенного __getitem__,
так и определение нового объекта
'''


class ImmutableContainer:
    '''Класс реализует поведение неизменяемого индексируемого объекта, схожего своим поведением с кортежем'''
    def __init__(self, *values):
        if not values:
            self.values = ()
        self.values = tuple(values)
    def __repr__(self):
        '''Представление имени объекта для простого контекстного восприятия. Основан на остатке от деления его id'''
        return f'<obj{id(self)%1000!r}>'
    def __str__(self):
        '''Представление пользовательского вида объекта, включающего repr-имя и все элементы объекта'''
        return f'{repr(self)} имеет значения: {self.values}'
    def __len__(self):
        return len(self.values)
    def __getitem__(self, key):
        '''Если передан параметр - item (индекс), то осуществляет получение элемента по нему.
        Либо, осуществляется получение всех элементов'''
        if self.keyValid(key):
            return self.values[key]
        return self.values

    def keyValid(self, key=None):
        '''Атрибут-валидатор, применяемый в методах для получения и удаления элементов контейнера, но не для установки.
         Осуществляет проверку корректности переданного значения ключа,
         при этом, учитывается возможная передача отрицательного значения индекса, но входящего в диапазон элементов,
         при обращении к элементам с конца массива'''
        if key:
            if not isinstance(key, int):
                raise TypeError('Индексом может быть только целое число')
            if not -(len(self.values)) <= key <= len(self.values):
                raise IndexError('Выход за пределы диапазона значений')
            return self.values[key]
        return self.values


class MutableContainer(ImmutableContainer):
    '''Класс реализует поведение изменяемого индексируемого объекта, схожего своим поведением со списком'''
    def __init__(self, *values):
        if not values:
            self.values = []
        self.values = list(values)
    def __setitem__(self, key, value):
        '''Метод не включает в себя валидатор корректности ключа, вместо этого применяется только проверка типа

        1. Реализация присвоения ненулевых значений массива, как это происходит с встроенными коллекциями:
        objA = [1, 2, 3]
        objA[:10] = [42]
        objA  # [1, 2, 3, 42]

        2. Реализация присвоения разряженного массива.
        Создает диапазон разницы, заполненный значениями None и присваивает его массиву в соответствии с положением ключа
        objB = [1, 2, 3]
        objB[:10] = [42]
        objB  # [1, 2, 3, None, None, None, None, None, None, None, 42]
        '''
        if not isinstance(key, int):
            raise TypeError('Индексом может быть только целое число')
        # Вариант 1. Присвоение массива по принципу встроенного типа списка
        # if 0 <= key <= len(self.values):
        #     self.values[key] = value
        # else:
        #     if key > len(self.values):
        #         self.values.append(value)
        #     elif key < len(self.values):
        #         self.values[:0] = [value]

        # Вариант 2. Присвоение разряженного массива
        if 0 <= key <= len(self.values):
            self.values[key] = value
        else:
            diff = abs(abs(key) - len(self.values))
            if key > len(self.values):
                self.values.extend([None] * diff + [value])
            elif key < len(self.values):
                self.values[:0] = ([value] + [None] * diff)

    def __add__(self, other):
        '''Реализует сложение (включение) только итерируемого объекта'''
        if not hasattr(other, '__iter__'):
            raise ValueError('Может быть включен только итерируемый объект')
        self.values.extend(other)
    def __delitem__(self, key):
        if self.keyValid(key):
            del self.values[key]


class IterableContainer(MutableContainer):
    '''Класс реализует поведение изменяемого индексируемого объекта, при этом определяя поведение при итерации объекта'''
    def __iter__(self):
        '''Метод реализует процесс итерирования элементов объекта
        Обычно возвращает только ссылку на объект - self, а также может реализовывать переменную-индекс, которая
        будет применена в методе __next__, как начальный индекс для итерирования элементов
        Также, переменная-индекс может быть реализована иначе, например, как изначальное свойство объекта при его
        инициализации, тогда потребуется переопределение переменной в условной конструкции метода __next__, как
        завершение предыдущего итерирования, при возникновении исключения StopIteration'''
        self.index = 0
        return self
    def __next__(self):
        '''Для исключения "ошибки" выхода за границы контейнера, применяется условие-ограничитель по его длине, которое
        при возникновении, станет указывать функции iter() на прекращение итерирования

        Переменная-индекс должна быть определена в методе __iter__ или любом другом пространстве объекта, но тогда, она
        должна быть переопределена в условной конструкции метода __next__, при наступлении StopIteration
        '''
        if self.index >= len(self.values):
            # self.index = 0  # Переопределение, если изначально переменная-индекс была реализована вне метода __iter__
            raise StopIteration
        elements = self.values[self.index]
        self.index += 1
        return elements


if __name__ == '__main__':
    print(' Построение неизменяемого контейнера, на основе определения методов __getitem__ и __len__ '.center(120, '-'))
    print('Объект поддерживает индексирование элементов и получение длины массива')
    my_tup = ImmutableContainer(1, 2, 3, 4, 5)
    print(f'Инициирован {my_tup}')
    print(f'Отображение элемента на нулевом индексе: {my_tup[0]}')
    print(f'Отображение длины объекта: {len(my_tup)}')
    print()

    print(' Построение изменяемого контейнера, на основе определения методов __setitem__ и __delitem__ '.center(120, '-'))
    print('Объект поддерживает индексирование, получение длины, а также установку и удаление элементов в массиве')
    my_lst = MutableContainer(1, 2, 3, 4, 5)
    print(f'Инициирован {my_lst}')
    del my_lst[-1]
    my_lst[0] = 'Hello, Word!'
    print(f'После удаления последнего элемента и замены первого элемента на "Hello, Word!", состав {my_lst}')
    my_lst + [10, 20, 30]
    print(f'После включения в объект массива [10, 20, 30], {my_lst}')
    print()

    print(' Внедрение методов __iter__ и __next__ '.center(120, '-'))
    print('Важно заметить, что функция iter() вызывается циклами неявно, для получения итератора от объекта, вызывая его метод __iter__.\n' 
          'Если метод не реализован, то вызванная явно или неявно, функция проверяет наличие метода __getitem__\n'
          'и если он реализован, то на его основе создается итератор, при этом, __getitem__ должен уметь принимать индекс с нуля.\n' 
          'Если не реализован ни один из этих методов, тогда будет вызвано исключение TypeError')
    print(f'Итерирование ранее определенного псевдокортежа {repr(my_tup)} в цикле: {[i for i in my_tup]}')
    print(f'Итерирование ранее определенного псевдосписка {repr(my_lst)} в цикле: {[i for i in my_lst]}')
    print()
    print('Создание нового объекта, который поддерживает индексирование, получение длины, установку, удаление элементов, '
          'а также пользовательские условия по итерированию элементов массива')
    cur_lst = IterableContainer(1, 2, 3)
    print(f'Инициирован {cur_lst}')
    cur_lst[-10] = 'hellooo'
    print(f'После добавления в объект разряженного массива, начиная с индекса -10, {cur_lst}')
    print(f'Итерирование объекта в цикле: {[i for i in cur_lst]}')
    print()
