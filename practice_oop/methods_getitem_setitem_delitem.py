'''Методы __getitem__, __setitem__ и __delitem__ для построения пользовательских контейнеров

Установка каждого из методов, вносит определенный функционал для работы с элементами объекта как содержимым коллекции:
- метод __getitem__ - позволяет осуществлять получение элемента по индексу;
- метод __setitem__ - позволяет осуществлять установку нового элемента по индексу;
- метод __delitem__ - позволяет осуществлять удаление элемента по индексу.
Методы применяются в протоколах построения пользовательских контейнеров, например, для большего сходства с типами
встроенных коллекций.


Создание классов:
- Построение базового класса ImmutableContainer, для создания на его основе неизменяемого контейнера.
Определяются методы __getitem__ и __len__.
Получение элемента в объекте, станет осуществляться через индексирование:
    в коде - self.data[key], в инструкциях для объекта - data[key];

- Построение производного класса MutableContainer, на основе предыдущего,
для создания на его основе изменяемого контейнера. Определяются методы __setitem__ и __delitem__.
Присвоение элемента объекту, станет осуществляться через индексирование:
    в коде - self.data[key] = value, в инструкциях для объекта - data[key] = value
Удаление элемента объекта, также станет осуществляться через индексирование:
    в коде - del self.data[key], в инструкциях для объекта - del data[key];

- Построение производного класса IterableContainer, на основе предыдущего,
для создания на его основе итерируемого контейнера. Определяются методы __iter__ и __next__.
Демонстрируется возможность как применения автоматического задействия ранее определенного __getitem__,
так и определение нового объекта
'''


class ImmutableContainer:
    '''Класс реализует поведение неизменяемого индексируемого объекта, схожего своим поведением с кортежем'''
    def __init__(self, *values):
        if not values:
            self.values = []
        self.values = list(values)
    def __repr__(self):
        return f'{self.values!r}'
    def __len__(self):
        return len(self.values)
    def __getitem__(self, key):
        '''Если передан параметр - item (индекс), то осуществляет получение элемента по нему.
        Либо, осуществляется получение всех элементов'''
        if self.keyValid(key):
            return self.values[key]
        return self.values

    def keyValid(self, key=None):
        '''Атрибут-валидатор, применяемый в методах для получения, установки и удаления элементов контейнера.
         Осуществляет проверку корректности переданного значения ключа,
         при этом, учитывается возможная передача отрицательного значения индекса, но входящего в диапазон элементов,
         при обращении к элементам с конца массива'''
        if key:
            if not isinstance(key, int):
                raise TypeError('Индексом может быть только целое число')
            if not -(len(self.values)) <= key <= len(self.values):
                raise IndexError('Выход за пределы диапазона значений')
            return self.values[key]
        return self.values


class MutableContainer(ImmutableContainer):
    '''Класс реализует поведение изменяемого индексируемого объекта, схожего своим поведением со списком'''
    def __setitem__(self, key, value):
        '''
        1. Реализация присвоения ненулевых значений массива, как это происходит с встроенными коллекциями:
        objA = [1, 2, 3]
        objA[:10] = [42]
        objA  # [1, 2, 3, 42]

        2. Реализация присвоения разряженного массива.
        Создает диапазон разницы, заполненный значениями None и присваивает его массиву в соответствии с положением ключа
        objB = [1, 2, 3]
        objB[:10] = [42]
        objB  # [1, 2, 3, None, None, None, None, None, None, None, 42]
        '''
        # Вариант 1. Присвоение массива по принципу встроенного типа списка
        # if 0 <= key <= len(self.values):
        #     self.values[key] = value
        # else:
        #     if key > len(self.values):
        #         self.values.append(value)
        #     elif key < len(self.values):
        #         self.values[:0] = [value]

        # Вариант 2. Присвоение разряженного массива
        if 0 <= key <= len(self.values):
            self.values[key] = value
        else:
            diff = abs(abs(key) - len(self.values))
            if key > len(self.values):
                self.values.extend([None] * diff + [value])
            elif key < len(self.values):
                self.values[:0] = ([value] + [None] * diff)

    def __add__(self, other):
        '''Реализует сложение (включение) только итерируемого объекта'''
        if not hasattr(other, '__iter__'):
            raise ValueError('Может быть включен только итерируемый объект')
        self.values.extend(other)
    def __delitem__(self, key):
        if self.keyValid(key):
            del self.values[key]


class IterableContainer(MutableContainer):
    '''Класс реализует поведение изменяемого индексируемого объекта, при этом определяя поведение при итерации объекта'''
    def __iter__(self):
        return iter(self.values)


if __name__ == '__main__':
    print(' Построение неизменяемого контейнера, на основе определения методов __getitem__ и __len__ '.center(120, '-'))
    print('Объект поддерживает индексирование элементов и получение длины массива')
    my_tup = ImmutableContainer(1, 2, 3, 4, 5)
    print(f'Отображение содержимого объекта: {my_tup}')
    print(f'Объект поддерживает индексирование. Отображение элемента на нулевом индексе: {my_tup[0]}')
    print(f'Объект поддерживает вычисление длины массива. Отображение длины объекта: {len(my_tup)}')
    print()

    print(' Построение изменяемого контейнера, на основе определения методов __setitem__ и __delitem__ '.center(120, '-'))
    print('Объект поддерживает индексирование, получение длины, а также установку и удаление элементов в массиве')
    my_lst = MutableContainer(1, 2, 3, 4, 5)
    print(f'Отображение содержимого объекта: {my_lst}')
    del my_lst[-1]
    my_lst[0] = 'Hello, Word!'
    print(f'Удален последний элемент, первому элементу присвоено новое значение: {my_lst}')
    my_lst + [10, 20, 30]
    print(f'Включение итерируемого объекта [10, 20, 30]: {my_lst}')
    print()

    print(' Построение неизменяемого контейнера, на основе определения методов __iter__ и __next__ '.center(120, '-'))
    print('Важно заметить, что функция iter() вызывается циклами неявно, для получения итератора из объекта, вызывая его метод __iter__.\n' 
          'Если метод не реализован, то вызванная явно или неявно, функция проверяет наличие метода __getitem__\n'
          'и если он реализован, то на его основе создается итератор, при этом, __getitem__ должен уметь принимать индекс с нуля.\n' 
          'Если не реализован ни один из этих методов, тогда будет вызвано исключение TypeError')
    print(f'Итерирование ранее определенного объекта псевдокортежа в цикле: {[i for i in my_tup]}')
    print(f'Итерирование ранее определенного объекта псевдосписка в цикле: {[i for i in my_lst]}')
    print('Создание нового объекта, который поддерживает индексирование, получение длины, установку, удаление элементов, '
          'а также пользовательские условия по итерированию элементов массива')
    cur_lst = IterableContainer(1, 2, 3)
    print(f'Отображение содержимого объекта: {cur_lst}')
    cur_lst[-10] = 'hellooooooooo'
    print(f'Добавление в объект разряженного массива: {cur_lst}')
    print(f'Итерирование объекта в цикле: {[i for i in cur_lst]}')
    print()
