'''
# Описание файла
Код повторяет приложение tk_app1.py
Но теперь дополняется многопоточностью, за счет добавления одноименного модуля
Моделирование работы sleep_func запускается в новом потоке


## Решение задачи производится исходя из требований ввода-вывода информации
Подход "многопоточности" применяется для решения легких задач
Например, cpu-интенсивные задачи, запросы к базе данных, обращения к API сервера и тп.

Для решения задачи, в текущем процессе запускается новый поток
В таких задачах код исполняется быстро, отправляя запрос, но с требованием ожидания по времени, для получения ответа.
Например, ответ может поступать за 0.5 секунд, тогда, код программы в это время простаивает и только ожидает ответа.

В одном процессе может быть запущенно бесконечное число потоков, которые станут делить между собой ресурсы, выделенные для данного процесса


### Такой подход имеет ряд ограничений:
• Если в рамках одного процесса, на ряду с потоками простых задач, запустить поток с тяжелой задачей, например, по рендеру видео, то его поток израсходует ресурсы всего процесса, тогда как прочим потокам останется недостаточно ресурсов для выполнения своих задач.

• Также, необходимо учитывать, что Python реализует работу в однопоточном режиме: Global Interpretator lock (GIL - блокировка глобального интерпретатора), позволяя в один момент времени выполняться только одному потоку.
Так, если текущая задача в потоке простаивает или ожидает ответа, например, ответа от сервера, то в таком случае, глобальный интерпретатор передает управление другому потоку, который требует ресурсов. Таким образом, технически, инструкции выполняются последовательнод друг за другом. 
Поэтому, несмотра на то, что по факту, может быть открыто неограниченное число потоков, на практике, в зависимости от конкретных исполняемых задач, в одном процессе применяется в среднем от 4 до 40 потоков
Например, если обработка запроса от сервера суммарно длится 250мс, из которых 200мс происходило ожидание, то эффективным станет планирование 5 потоков. 
Хотя, бывает и так, что получается уместить большее число потоков в одном процессе. Но необходимо учитывать, что для переключения между потоками, также требуется время, поэтому наступает момент, когда дальнейшее увеличение количества потоков, нивелирует преимущество от их числа

В примере ниже существует два потока: цикл событий функции mainloop, для обновления состояния окна приложения, и функция start_sleep_thread, для моделирования выполнения работы приложения.
'''

import tkinter as tk
from tkinter import ttk
import time
import threading

root = tk.Tk()
root.geometry('300x300+150+150')

def sleep_func():
    time.sleep(10)
    lab['text'] = 'Прошло 10 секунд\nЗадача выполнена в новом потоке'

def start_sleep_thread():
    thread = threading.Thread(target=sleep_func)
    thread.start()


# btn = ttk.Button(root, text='Run', command=sleep_func)  # Синхронное выполнение. Функция sleep_func запускается в том же потоке
btn = ttk.Button(root, text='Run', command=start_sleep_thread)  # Многопоточное выполнение. Функции sleep_func запускается в отдельном потоке
btn.place(relx=0.5, rely=0.2, anchor=tk.CENTER)

lab = ttk.Label(root, text='Текст до нажатия')
lab.place(relx=0.5, rely=0.6, anchor=tk.CENTER)




if __name__ == '__main__':
    root.mainloop()
