'''
# Реализация работы двух задач в псевдо-асинхронном виде
Печать содержимого директории и периодическая печать дополнительного сообщения
Функции, возвращающие значения, преобразуются в генераторы.
Итераторы генераторов поэтапно возвращают результаты вычислений в цикле while, что позволяет равномерно по времени получать результы всех запущенных (легких по функциональности) задач, что схоже по своему виду с асинхронным выполнением.


## Прерывание вывода
- Прерывание вывода осуществляется автоматически, при истощении итераторов
- Прерывание вывода может быть организовано генерацией сигнала SIGINT (Ctrl + C) в unix-подобных операционных системах, а в Python обычно соответствует исключению KeyboardInterrupt


## Обработка исключений
Корректная обработка исключений, при истощении итераторов или получении сигнала SIGINT от пользователя, осуществляется в обертке конструкции try/except  


## Фильтр-исключение для директорий
Метод os.walk на каждой итерации проходит по каждой директории в текущем узле дерева каталогов, возвращая кортеж (root, dirs, files), где root - это текущая директория, dirs - список дочерних директорий, а files - список файлов в текущей директории

Благодаря свойствам генератора filter_walk, в нем сохраняется состояние локальных переменных.
Внося изменения в состав элементов dirs - директорий, фактически изменяется сам список, на который ссылается переменная dirs.
Таким образом, на каждой последующей итерации метода os.walk внутри функции filtered_walk, список dirs будет обновляться в соответствии с примененным фильтром исключения, а метод walk итерировать только директории, которые не вошли в фильтр-исключение


## Применение модуля signal
Модуль применяться для особой обработки сигналов, таких как SIGTERM, SIGHUP, SIGUSR1, и т.д. например, при выполнении кода, перед тем, как завершить программу, для корректного закрытия файлов, сохранения состояния или логирования
'''

import time
import os


def clock():
    time0 = round(time.time())  # Локальная переменная, сохраняющая свое состояние после запуска
    while True:
        if (round(time.time()) - time0) % 5 == 0:
            yield '\nTask continues\n5 seconds have passed'
        else:
            yield 0

def filter_walk(top):
    excluded_dirs = {'__pycache__', 'module_django', 'tests', '.git', '.idea', '.mypy_cache', '.gitignore', 'test.py', 'test2.py', 'test3.py'}  # Директории, которые следует отсечь из вывода
    for dpath, dnames, fnames in os.walk(top):
        dnames[:] = [d for d in dnames if d not in excluded_dirs]  # Локальная переменная, сохраняющая свое состояние после запуска
        yield dpath, dnames, fnames


def query(top='C:/GoogleDrive/Python'):
    for dpath, dnames, fnames in filter_walk(top):
        yield f'\n({len(fnames)}) {dpath}'


def main():
    '''Псевдо-событийный цикл'''
    # Генраторы query и clock возвращают объекты-ожидания, через которые будут ожидать получение запроса на выполнение операций, а выполнив его, вновь останавливаются на ожидание
    # Главным условием, в подобных однопоточных системах, является обязательное исключение функций, блокирующих поток. Когда например, одной из выполняемых функций может быть некий запрос к пользователю. В таком случае, возникновение такого запроса, остановит работу всего событийного цикла, потому как функция, ожидающая ответа от пользователя, находится в состоянии выполнения инструкции
    data = query()
    info = clock()

    try:
        while True:
            d = next(data)
            i = next(info)
            print(d)
            if i: print(i)  # Если генератор вернет истинное значение. На самом деле "когда" вернет (в указанном диапазоне времени)
            time.sleep(1)

    except StopIteration:
        print("\nThe 'query' generator has finished executing.")
    except KeyboardInterrupt:
        print("\nProgram has been interrupted by user.")



if __name__ == '__main__':
    main()
