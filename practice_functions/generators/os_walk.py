'''
# Вывод директорий с фильтром-исключения
Метод os.walk на каждой итерации проходит по каждой директории в текущем узле дерева каталогов, возвращая кортеж (root, dirs, files), где root - это текущая директория, dirs - список дочерних директорий, а files - список файлов в текущей директории


## Применение полного среза [:]
В контексте вызова os.walk(), осуществляется генерация объектов, среди которых существует dnames, который будет использоваться для итераций по поддиректориям. Что важно, если этот объект изменится, то результат последующей итерации будет изменен.

Важно учитывать, что dnames в этом случае - это не просто данные для чтения, но и для записи, которые os.walk() использует для определения, куда "шагать" дальше. Изменяя dnames "на месте" с помощью среза dnames[:], мы фактически изменяем путь обхода, которым следует os.walk()

Применение полного среза dnames[:] = ... изменяет исходный объект dnames (подобное называют как "изменение на месте"), то есть без изменения его идентификатора в памяти. Это в свою очередь означает, что все изменения применяются непосредственно к списку, который os.walk() использует для продолжения обхода директорий.

При обычном присвоении dnames = value, создается новый объект с идентификатором dnames и другой ссылкой, что не повлияет на последовательность, с которой os.walk() продолжит работать, потому что внутренняя ссылка на старый список останется неизменной и os.walk() продолжит использовать его, не замечая изменений, внесенных в новый список.
'''

import os
import time


def filtered_os_wall(top):
    excluded_dirs = ('.vscode','__pycache__', 'module_django', 'tests', '.git', '.idea', '.mypy_cache', '.gitignore', 'test.py', 'test2.py', 'test3.py')  # Директории, которые следует отсечь из вывода
    for dpath, dnames, fnames in os.walk(top):
        dnames[:] = [d for d in dnames if d not in excluded_dirs]
        yield f'\n({len(fnames)}) {dpath}'

def main():
    query = filtered_os_wall('C:/GoogleDrive/Python')

    try:
        while True:
            q = next(query)
            print(q)
            time.sleep(1)

    except StopIteration:
        print("\nThe 'query' generator has finished executing.")
    except KeyboardInterrupt:
        print("\nProgram has been interrupted by user.")




if __name__ == '__main__':
    main()
