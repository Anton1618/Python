'''
# Реализация работы двух задач в псевдо-асинхронном виде
Печать содержимого директории и периодическая печать дополнительного сообщения
Без псевдо-асинхронного подхода в однопоточном python, не удастся запустить две функции одновременно и будучи запущенной, первая функция не даст возможности запустить вторую, до тех пор, пока первая не завершит выполнение.


## Реализация псевдо-асинхронной работы
Для реализации псевдо-асинхронности, простые функции преобразуют в генераторы.
Это позволяет создавать от них объекты объекты-генераторы с ленивыми вычислениями, которые затем можно будет поочередно вызывать в цикле while, поочередно возвращая результаты работы каждой из функций. 
Таким образом, псевдо-событийный цикл станет равномерно по времени выполнять запущенные задачи (легкие по функциональности), что схоже по своему принципу с асинхронным выполнением.

Однако, реализация не является асинхронной в полном смысле этого слова, ведь функции генераторы не выполняют I/O операций и не "отдают" управление обратно event loop (который представлен псевдо-событийным циклом в виде функции main()), ожидая их завершения.
Вместо этого, они просто приостанавливают свое выполнение и возобновляют его при следующем вызове next().
Таким образом, выполнение кода остается в основном потоке и другие операции не могут выполняться в этом время (за исключением прерывания по таймеру, как в примере с функцией clock())


## Описание работы
Корректная работа и завершение работы событийного цикла производится в конструкции try/except, что позволяет производить
- Автоматическое прерывание событийного цикла, при истощении итератора
- Прерывание вывода, через генерацию сигнала SIGINT (Ctrl + C) в unix-подобных операционных системах, что в Python обычно соответствует исключению KeyboardInterrupt

Фильтр-исключение для директорий
Метод os.walk на каждой итерации проходит по каждой директории в текущем узле дерева каталогов, возвращая кортеж (root, dirs, files), где root - это текущая директория, dirs - список дочерних директорий, а files - список файлов в текущей директории
Подробности работы генератора и применения среза [:], расматривается в соответствующем файле: python/function/generators/os_walk.py
'''

import time
import os


def clock():
    time0 = round(time.time())  # Локальная переменная, сохраняющая свое состояние после запуска
    while True:
        if (round(time.time()) - time0) % 5 == 0:
            yield '\nTask continues\n5 seconds have passed'
        else:
            yield 0


def filtered_os_wall(top):
    excluded_dirs = ('.vscode','__pycache__', 'module_django', 'tests', '.git', '.idea', '.mypy_cache', '.gitignore', 'test.py', 'test2.py', 'test3.py')  # Директории, которые следует отсечь из вывода
    for dpath, dnames, fnames in os.walk(top):
        dnames[:] = [d for d in dnames if d not in excluded_dirs]
        yield f'\n({len(fnames)}) {dpath}'


def main():
    '''
    Псевдо-событийный цикл, в котором генераторы query и clock возвращают свои объекты-генераторы (сущности с ленивыми вычислениями, для выполнения задач по запросу), через которые можно запрашивать и получать результаты работы генераторов. А после их выполнения, приостанавливаться на ожидание
    '''
    data = filtered_os_wall('C:/GoogleDrive/Python')
    info = clock()

    try:
        while True:
            d = next(data)
            i = next(info)
            print(d)
            if i: print(i)  # Если (точнее когда) генератор вернет истинное значение
            time.sleep(1)

    except StopIteration:
        print("\nThe 'query' generator has finished executing.")
    except KeyboardInterrupt:
        print("\nProgram has been interrupted by user.")



if __name__ == '__main__':
    main()
